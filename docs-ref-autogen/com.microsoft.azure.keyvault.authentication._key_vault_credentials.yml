### YamlMime:ManagedReference
items:
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    id: _key_vault_credentials
    parent: com.microsoft.azure.keyvault.authentication
    children:
      - com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter(OkHttpClient.Builder)
      - 'com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)'
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    langs:
      - java
    name: KeyVaultCredentials
    nameWithType: KeyVaultCredentials
    fullName: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials
    type: Class
    source:
      remote: &ref_0
        path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
        branch: bb950b2a0255c017040501de0c19e4849361ca1d
        repo: 'https://github.com/Azure/azure-keyvault-java'
      path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
      startLine: 26
    package: com.microsoft.azure.keyvault.authentication
    summary: '<p><span data-ttu-id="a64a1-101">Eine Implementierung der <xref uid="" data-throw-if-not-resolved="false">ServiceClientCredentials</xref> , die Aktualisierung des Zugriffstokens automatische Träger unterstützt.</span><span class="sxs-lookup"><span data-stu-id="a64a1-101">An implementation of <xref uid="" data-throw-if-not-resolved="false">ServiceClientCredentials</xref> that supports automatic bearer token refresh.</span></span> </p>'
    syntax:
      content: public class KeyVaultCredentials
    inheritance:
      - java.lang.Object
      - ServiceClientCredentials
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter(OkHttpClient.Builder)
    id: Builder)
    parent: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    langs:
      - java
    name: applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
    nameWithType: KeyVaultCredentials.applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
    fullName: void com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
    overload: com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter*
    type: Method
    source:
      remote: *ref_0
      path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
      startLine: 35
    package: com.microsoft.azure.keyvault.authentication
    syntax:
      content: public void applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
      parameters:
        - id: clientBuilder
          type: 2c0be77c
  - uid: 'com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)'
    id: 'doAuthenticate(String,String,String)'
    parent: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    langs:
      - java
    name: 'doAuthenticate(String authorization, String resource, String scope)'
    nameWithType: 'KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    fullName: 'abstract String com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    overload: com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate*
    type: Method
    source:
      remote: *ref_0
      path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
      startLine: 215
    package: com.microsoft.azure.keyvault.authentication
    summary: "<p><span data-ttu-id=\"a64a1-102\">Abstrakte Methode, die implementiert werden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"a64a1-102\">Abstract method to be implemented.</span></span></p>\n<p>\n<span data-ttu-id=\"a64a1-103\">Private statische AuthenticationResult GetAccessTokenFromClientCredentials (String-Autorisierung, Zeichenfolgenressource, ClientId Zeichenfolge, Zeichenfolge ClientKey) {AuthenticationContext Kontext = Null; AuthenticationResult Ergebnis = Null; ExecutorService Dienst = Null; Wiederholen Sie den {Dienst = Executors.newFixedThreadPool(1); Kontext = neue AuthenticationContext (Autorisierung, \"false\" Service;) ClientCredential-Anmeldeinformationen = neue ClientCredential (ClientId, ClientKey); Zukünftige&lt;AuthenticationResult&gt; zukünftige = context.acquireToken (Resource, Anmeldeinformationen, null); Ergebnis = future.get();} catch (Exception e) {auslösen neue RuntimeException(e);} schließlich {service.shutdown();}</span><span class=\"sxs-lookup\"><span data-stu-id=\"a64a1-103\">private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource, String clientId, String clientKey) { AuthenticationContext context = null; AuthenticationResult result = null; ExecutorService service = null; try { service = Executors.newFixedThreadPool(1); context = new AuthenticationContext(authorization, false, service); ClientCredential credentials = new ClientCredential(clientId, clientKey); Future&lt;AuthenticationResult&gt; future = context.acquireToken(resource, credentials, null); result = future.get(); } catch (Exception e) { throw new RuntimeException(e); } finally { service.shutdown(); }</span></span></p>\n<p><span data-ttu-id=\"a64a1-104\">Wenn (Ergebnis == Null) {neue RuntimeException auslösen (\"Authentifizierungsergebnis war null\");} Rückgabeergebnis; }</span><span class=\"sxs-lookup\"><span data-stu-id=\"a64a1-104\">if (result == null) { throw new RuntimeException(\"authentication result was null\"); } return result; }</span></span> </p>\n<p><span data-ttu-id=\"a64a1-105\">\r\n\r\n  <b>Hinweis: Der Clientschlüssel muss sicher gespeichert werden. Empfohlen hat zwei Clientanwendungen: 1 für Entwicklung und andere für die Produktion - von separaten Parteien verwaltet verwenden.</b>\r\n\r\n</span><span class=\"sxs-lookup\"><span data-stu-id=\"a64a1-105\">\r\n\r\n  <b>Note: The client key must be securely stored. It's advised to use two client applications - one for development and other for production - managed by separate parties.</b>\r\n\r\n</span></span></p>"
    syntax: &ref_1
      content: 'public abstract String doAuthenticate(String authorization, String resource, String scope)'
      parameters:
        - id: authorization
          type: '26831127'
          description: '<p><span data-ttu-id="a64a1-106">Der Bezeichner der Autorisierungsstelle, eine URL.</span><span class="sxs-lookup"><span data-stu-id="a64a1-106">Identifier of the authority, a URL.</span></span> </p>'
        - id: resource
          type: '26831127'
          description: '<p><span data-ttu-id="a64a1-107">Der Bezeichner der Zielressource, die den Empfänger des angeforderten Tokens, eine URL ist.</span><span class="sxs-lookup"><span data-stu-id="a64a1-107">Identifier of the target resource that is the recipient of the requested token, a URL.</span></span> </p>'
        - id: scope
          type: '26831127'
          description: <p><span data-ttu-id="a64a1-108">Der Bereich der Authentifizierungsanforderung.</span><span class="sxs-lookup"><span data-stu-id="a64a1-108">The scope of the authentication request.</span></span></p>
      return:
        type: 9065866d
        description: |-
          <p><span data-ttu-id="a64a1-109">Das Zugriffstoken <verbatim> eine Abfrage des Servers mit einem token Header Antworten.</span><span class="sxs-lookup"><span data-stu-id="a64a1-109">The access token <verbatim>    Answers a server challenge with a token header.</span></span>

              &lt;p&gt;

              Implementations typically use ADAL to get a token, as performed

              in the sample below:

              &lt;/p&gt;



              &lt;pre&gt;

          <span data-ttu-id="a64a1-110"></verbatim>&amp;#064; öffentliche Zeichenfolge für Überschreibung <xref uid="com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)" data-throw-if-not-resolved="false">DoAuthenticate (String-Autorisierung, Zeichenfolgenressource Zeichenfolge Bereich)</xref> {ClientId Zeichenfolge =...; / / Client-GUID wie in der Azure-Portal dargestellt.</span><span class="sxs-lookup"><span data-stu-id="a64a1-110"></verbatim> &amp;#064;Override public String <xref uid="com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)" data-throw-if-not-resolved="false">doAuthenticate(String authorization, String resource, String scope)</xref> { String clientId = ...; // client GUID as shown in Azure portal.</span></span> <span data-ttu-id="a64a1-111">Eine Zeichenfolge ClientKey =...; Clientschlüssel Azure-Portal bereitgestellt.</span><span class="sxs-lookup"><span data-stu-id="a64a1-111">String clientKey = ...; // client key as provided by Azure portal.</span></span> <span data-ttu-id="a64a1-112">AuthenticationResult Token = GetAccessTokenFromClientCredentials (Autorisierung, Ressourcen, ClientId, ClientKey); Zurückgeben von token.getAccessToken(); }</span><span class="sxs-lookup"><span data-stu-id="a64a1-112">AuthenticationResult token = getAccessTokenFromClientCredentials(authorization, resource, clientId, clientKey); return token.getAccessToken();; }</span></span></p>
references:
  - uid: 2c0be77c
    spec.java:
      - name: OkHttpClient.Builder
        fullName: OkHttpClient.Builder
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter*
    name: applyCredentialsFilter
    nameWithType: KeyVaultCredentials.applyCredentialsFilter
    fullName: void com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter
    package: com.microsoft.azure.keyvault.authentication
  - uid: '26831127'
    spec.java:
      - name: String
        fullName: String
  - uid: 9065866d
    spec.java:
      - name: abstract String
        fullName: abstract String
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate*
    name: doAuthenticate
    nameWithType: KeyVaultCredentials.doAuthenticate
    fullName: abstract String com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate
    package: com.microsoft.azure.keyvault.authentication
  - uid: 'com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)'
    parent: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    name: 'doAuthenticate(String authorization, String resource, String scope)'
    nameWithType: 'KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    fullName: 'abstract String com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    type: Method
    summary: "<p><span data-ttu-id=\"a64a1-113\">Abstrakte Methode, die implementiert werden.</span><span class=\"sxs-lookup\"><span data-stu-id=\"a64a1-113\">Abstract method to be implemented.</span></span></p>\n<p>\n<span data-ttu-id=\"a64a1-114\">Private statische AuthenticationResult GetAccessTokenFromClientCredentials (String-Autorisierung, Zeichenfolgenressource, ClientId Zeichenfolge, Zeichenfolge ClientKey) {AuthenticationContext Kontext = Null; AuthenticationResult Ergebnis = Null; ExecutorService Dienst = Null; Wiederholen Sie den {Dienst = Executors.newFixedThreadPool(1); Kontext = neue AuthenticationContext (Autorisierung, \"false\" Service;) ClientCredential-Anmeldeinformationen = neue ClientCredential (ClientId, ClientKey); Zukünftige&lt;AuthenticationResult&gt; zukünftige = context.acquireToken (Resource, Anmeldeinformationen, null); Ergebnis = future.get();} catch (Exception e) {auslösen neue RuntimeException(e);} schließlich {service.shutdown();}</span><span class=\"sxs-lookup\"><span data-stu-id=\"a64a1-114\">private static AuthenticationResult getAccessTokenFromClientCredentials(String authorization, String resource, String clientId, String clientKey) { AuthenticationContext context = null; AuthenticationResult result = null; ExecutorService service = null; try { service = Executors.newFixedThreadPool(1); context = new AuthenticationContext(authorization, false, service); ClientCredential credentials = new ClientCredential(clientId, clientKey); Future&lt;AuthenticationResult&gt; future = context.acquireToken(resource, credentials, null); result = future.get(); } catch (Exception e) { throw new RuntimeException(e); } finally { service.shutdown(); }</span></span></p>\n<p><span data-ttu-id=\"a64a1-115\">Wenn (Ergebnis == Null) {neue RuntimeException auslösen (\"Authentifizierungsergebnis war null\");} Rückgabeergebnis; }</span><span class=\"sxs-lookup\"><span data-stu-id=\"a64a1-115\">if (result == null) { throw new RuntimeException(\"authentication result was null\"); } return result; }</span></span> </p>\n<p><span data-ttu-id=\"a64a1-116\">\r\n\r\n  <b>Hinweis: Der Clientschlüssel muss sicher gespeichert werden. Empfohlen hat zwei Clientanwendungen: 1 für Entwicklung und andere für die Produktion - von separaten Parteien verwaltet verwenden.</b>\r\n\r\n</span><span class=\"sxs-lookup\"><span data-stu-id=\"a64a1-116\">\r\n\r\n  <b>Note: The client key must be securely stored. It's advised to use two client applications - one for development and other for production - managed by separate parties.</b>\r\n\r\n</span></span></p>"
    syntax: *ref_1