### YamlMime:ManagedReference
items:
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    id: _key_vault_credentials
    parent: com.microsoft.azure.keyvault.authentication
    children:
      - com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter(OkHttpClient.Builder)
      - 'com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)'
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    langs:
      - java
    name: KeyVaultCredentials
    nameWithType: KeyVaultCredentials
    fullName: com.microsoft.azure.keyvault.authentication.KeyVaultCredentials
    type: Class
    source:
      remote: &ref_0
        path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
        branch: bb950b2a0255c017040501de0c19e4849361ca1d
        repo: 'https://github.com/Azure/azure-keyvault-java'
      path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
      startLine: 26
    package: com.microsoft.azure.keyvault.authentication
    summary: '<p>Eine Implementierung der <ref refid="" kindref="compound">ServiceClientCredentials</ref> , die Aktualisierung des Zugriffstokens automatische Träger unterstützt. </p>'
    syntax:
      content: public class KeyVaultCredentials
    inheritance:
      - java.lang.Object
      - ServiceClientCredentials
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter(OkHttpClient.Builder)
    id: Builder)
    parent: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    langs:
      - java
    name: applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
    nameWithType: KeyVaultCredentials.applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
    fullName: void com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
    overload: com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter*
    type: Method
    source:
      remote: *ref_0
      path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
      startLine: 35
    package: com.microsoft.azure.keyvault.authentication
    syntax:
      content: public void applyCredentialsFilter(OkHttpClient.Builder clientBuilder)
      parameters:
        - id: clientBuilder
          type: 2c0be77c
  - uid: 'com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)'
    id: 'doAuthenticate(String,String,String)'
    parent: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    langs:
      - java
    name: 'doAuthenticate(String authorization, String resource, String scope)'
    nameWithType: 'KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    fullName: 'abstract String com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    overload: com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate*
    type: Method
    source:
      remote: *ref_0
      path: azure-keyvault/src/main/java/com/microsoft/azure/keyvault/authentication/KeyVaultCredentials.java
      startLine: 215
    package: com.microsoft.azure.keyvault.authentication
    summary: "<p>Abstrakte Methode, die implementiert werden.</p>\n<p>\nPrivate statische AuthenticationResult GetAccessTokenFromClientCredentials (String-Autorisierung, Zeichenfolgenressource, ClientId Zeichenfolge, Zeichenfolge ClientKey) {AuthenticationContext Kontext = Null; AuthenticationResult Ergebnis = Null; ExecutorService Dienst = Null; Wiederholen Sie den {Dienst = Executors.newFixedThreadPool(1); Kontext = neue AuthenticationContext (Autorisierung, \"false\" Service;) ClientCredential-Anmeldeinformationen = neue ClientCredential (ClientId, ClientKey); Zukünftige&lt;AuthenticationResult&gt; zukünftige = context.acquireToken (Resource, Anmeldeinformationen, null); Ergebnis = future.get();} catch (Exception e) {auslösen neue RuntimeException(e);} schließlich {service.shutdown();}</p>\n<p>Wenn (Ergebnis == Null) {neue RuntimeException auslösen (\"Authentifizierungsergebnis war null\");} Rückgabeergebnis; } </p>\n<p>\r\n\r\n  <bold>Hinweis: Der Clientschlüssel muss sicher gespeichert werden. Empfohlen hat zwei Clientanwendungen: 1 für Entwicklung und andere für die Produktion - von separaten Parteien verwaltet verwenden.</bold>\r\n\r\n</p>"
    syntax: &ref_1
      content: 'public abstract String doAuthenticate(String authorization, String resource, String scope)'
      parameters:
        - id: authorization
          type: '26831127'
          description: '<p>Der Bezeichner der Autorisierungsstelle, eine URL. </p>'
        - id: resource
          type: '26831127'
          description: '<p>Der Bezeichner der Zielressource, die den Empfänger des angeforderten Tokens, eine URL ist. </p>'
        - id: scope
          type: '26831127'
          description: <p>Der Bereich der Authentifizierungsanforderung.</p>
      return:
        type: 9065866d
        description: |-
          <p>Das Zugriffstoken <verbatim> eine Abfrage des Servers mit einem token Header Antworten.

              &lt;p&gt;

              Implementations typically use ADAL to get a token, as performed

              in the sample below:

              &lt;/p&gt;



              &lt;pre&gt;

          </verbatim>&amp;#064; öffentliche Zeichenfolge für Überschreibung <xref href="com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)" data-throw-if-not-resolved="false"></xref> {ClientId Zeichenfolge =...; / / Client-GUID wie in der Azure-Portal dargestellt. Eine Zeichenfolge ClientKey =...; Clientschlüssel Azure-Portal bereitgestellt. AuthenticationResult Token = GetAccessTokenFromClientCredentials (Autorisierung, Ressourcen, ClientId, ClientKey); Zurückgeben von token.getAccessToken(); }</p>
references:
  - uid: 2c0be77c
    spec.java:
      - name: OkHttpClient.Builder
        fullName: OkHttpClient.Builder
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials.applyCredentialsFilter*
    name: applyCredentialsFilter
    nameWithType: KeyVaultCredentials.applyCredentialsFilter
    fullName: void com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.applyCredentialsFilter
    package: com.microsoft.azure.keyvault.authentication
  - uid: '26831127'
    spec.java:
      - name: String
        fullName: String
  - uid: 9065866d
    spec.java:
      - name: abstract String
        fullName: abstract String
  - uid: com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate*
    name: doAuthenticate
    nameWithType: KeyVaultCredentials.doAuthenticate
    fullName: abstract String com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate
    package: com.microsoft.azure.keyvault.authentication
  - uid: 'com.microsoft.azure.keyvault.authentication._key_vault_credentials.doAuthenticate(String,String,String)'
    parent: com.microsoft.azure.keyvault.authentication._key_vault_credentials
    href: com.microsoft.azure.keyvault.authentication._key_vault_credentials.yml
    name: 'doAuthenticate(String authorization, String resource, String scope)'
    nameWithType: 'KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    fullName: 'abstract String com.microsoft.azure.keyvault.authentication.KeyVaultCredentials.doAuthenticate(String authorization, String resource, String scope)'
    type: Method
    summary: "<p>Abstrakte Methode, die implementiert werden.</p>\n<p>\nPrivate statische AuthenticationResult GetAccessTokenFromClientCredentials (String-Autorisierung, Zeichenfolgenressource, ClientId Zeichenfolge, Zeichenfolge ClientKey) {AuthenticationContext Kontext = Null; AuthenticationResult Ergebnis = Null; ExecutorService Dienst = Null; Wiederholen Sie den {Dienst = Executors.newFixedThreadPool(1); Kontext = neue AuthenticationContext (Autorisierung, \"false\" Service;) ClientCredential-Anmeldeinformationen = neue ClientCredential (ClientId, ClientKey); Zukünftige&lt;AuthenticationResult&gt; zukünftige = context.acquireToken (Resource, Anmeldeinformationen, null); Ergebnis = future.get();} catch (Exception e) {auslösen neue RuntimeException(e);} schließlich {service.shutdown();}</p>\n<p>Wenn (Ergebnis == Null) {neue RuntimeException auslösen (\"Authentifizierungsergebnis war null\");} Rückgabeergebnis; } </p>\n<p>\r\n\r\n  <bold>Hinweis: Der Clientschlüssel muss sicher gespeichert werden. Empfohlen hat zwei Clientanwendungen: 1 für Entwicklung und andere für die Produktion - von separaten Parteien verwaltet verwenden.</bold>\r\n\r\n</p>"
    syntax: *ref_1