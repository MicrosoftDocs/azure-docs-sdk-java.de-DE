### YamlMime:ManagedReference
items:
  - uid: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher
    id: _reactor_dispatcher
    parent: com.microsoft.azure.eventhubs.amqp
    children:
      - com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.invoke(final DispatchHandler)
      - 'com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.invoke(final int,final DispatchHandler)'
      - com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.ReactorDispatcher(final Reactor)
    href: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.yml
    langs:
      - java
    name: ReactorDispatcher
    nameWithType: ReactorDispatcher
    fullName: com.microsoft.azure.eventhubs.amqp.ReactorDispatcher
    type: Class
    source:
      remote: &ref_0
        path: azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/amqp/ReactorDispatcher.java
        branch: master
        repo: 'https://github.com/Azure/azure-event-hubs-java'
      path: azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/amqp/ReactorDispatcher.java
      startLine: 28
    package: com.microsoft.azure.eventhubs.amqp
    summary: "<p><span data-ttu-id=\"d4e71-101\">\r\n\r\n  <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref> ist nicht threadsicher - alle Aufrufe an <xref uid=\"\" data-throw-if-not-resolved=\"false\">Proton</xref> -APIs werden sollten - Reaktor-Thread.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-101\">\r\n\r\n  <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref> is not thread-safe - all calls to <xref uid=\"\" data-throw-if-not-resolved=\"false\">Proton</xref> API's should be - on the Reactor Thread.</span></span> <span data-ttu-id=\"d4e71-102\"><xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref> funktioniert der Out-of-Box für alle ereignisgesteuert-API - ex: OnReceive – die nach OnSocketRead auslösen könnten.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-102\"><xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref> works out-of-box for all event driven API - ex: onReceive - which could raise upon onSocketRead.</span></span> <span data-ttu-id=\"d4e71-103\"><xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref> hat-APIs unterstützt, z. B. Send() Out-of-Box - die potenziell in anderen Thread der Reaktor ausgeführt werden kann.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-103\"><xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref> didn't support API's like Send() out-of-box - which could potentially run on different thread to that of Reactor.</span></span> <span data-ttu-id=\"d4e71-104\">Die folgenden Hilfsprogrammklasse daher dient zum Generieren eines Ereignisses Hook <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref>des delegationsmuster Ereignis.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-104\">So, the following utility class is used to generate an Event to hook into <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref>'s event delegation pattern.</span></span> <span data-ttu-id=\"d4e71-105\">Er verwendet ein <xref uid=\"\" data-throw-if-not-resolved=\"false\">Pipe</xref> als die e/a, auf welche Reaktor überwacht.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-105\">It uses a <xref uid=\"\" data-throw-if-not-resolved=\"false\">Pipe</xref> as the IO on which Reactor Listens to.</span></span> <span data-ttu-id=\"d4e71-106\">Kardinalität: mehrere <xref uid=\"com.microsoft.azure.eventhubs.amqp._reactor_dispatcher\" data-throw-if-not-resolved=\"false\">ReactorDispatcher</xref>des angefügt werden konnte, um 1 <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref>.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-106\">Cardinality: multiple <xref uid=\"com.microsoft.azure.eventhubs.amqp._reactor_dispatcher\" data-throw-if-not-resolved=\"false\">ReactorDispatcher</xref>'s could be attached to 1 <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref>.</span></span> <span data-ttu-id=\"d4e71-107\">Jede <xref uid=\"com.microsoft.azure.eventhubs.amqp._reactor_dispatcher\" data-throw-if-not-resolved=\"false\">ReactorDispatcher</xref> sollten synchron - initialisiert werden, wie es den API-Aufrufe <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref> die nicht threadsicher ist.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-107\">Each <xref uid=\"com.microsoft.azure.eventhubs.amqp._reactor_dispatcher\" data-throw-if-not-resolved=\"false\">ReactorDispatcher</xref> should be initialized Synchronously - as it calls API in <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref> which is not thread-safe.</span></span> </p>"
    syntax: &ref_1
      content: public class ReactorDispatcher
    inheritance:
      - java.lang.Object
  - uid: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.invoke(final DispatchHandler)
    id: invoke(final DispatchHandler)
    parent: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher
    href: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.yml
    langs:
      - java
    name: invoke(final DispatchHandler timerCallback)
    nameWithType: ReactorDispatcher.invoke(final DispatchHandler timerCallback)
    fullName: void com.microsoft.azure.eventhubs.amqp.ReactorDispatcher.invoke(final DispatchHandler timerCallback)
    overload: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.invoke*
    type: Method
    source:
      remote: *ref_0
      path: azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/amqp/ReactorDispatcher.java
      startLine: 54
    package: com.microsoft.azure.eventhubs.amqp
    syntax:
      content: public void invoke(final DispatchHandler timerCallback)
      parameters:
        - id: timerCallback
          type: 93de0ef9com.microsoft.azure.eventhubs.amqp._dispatch_handler
  - uid: 'com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.invoke(final int,final DispatchHandler)'
    id: 'invoke(final int,final DispatchHandler)'
    parent: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher
    href: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.yml
    langs:
      - java
    name: 'invoke(final int delay, final DispatchHandler timerCallback)'
    nameWithType: 'ReactorDispatcher.invoke(final int delay, final DispatchHandler timerCallback)'
    fullName: 'void com.microsoft.azure.eventhubs.amqp.ReactorDispatcher.invoke(final int delay, final DispatchHandler timerCallback)'
    overload: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.invoke*
    type: Method
    source:
      remote: *ref_0
      path: azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/amqp/ReactorDispatcher.java
      startLine: 59
    package: com.microsoft.azure.eventhubs.amqp
    syntax:
      content: 'public void invoke(final int delay, final DispatchHandler timerCallback)'
      parameters:
        - id: delay
          type: cd225469
        - id: timerCallback
          type: 93de0ef9com.microsoft.azure.eventhubs.amqp._dispatch_handler
  - uid: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.ReactorDispatcher(final Reactor)
    id: ReactorDispatcher(final Reactor)
    parent: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher
    href: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.yml
    langs:
      - java
    name: ReactorDispatcher(final Reactor reactor)
    nameWithType: ReactorDispatcher.ReactorDispatcher(final Reactor reactor)
    fullName: com.microsoft.azure.eventhubs.amqp.ReactorDispatcher.ReactorDispatcher(final Reactor reactor)
    overload: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.ReactorDispatcher*
    type: Constructor
    source:
      remote: *ref_0
      path: azure-eventhubs/src/main/java/com/microsoft/azure/eventhubs/amqp/ReactorDispatcher.java
      startLine: 34
    package: com.microsoft.azure.eventhubs.amqp
    syntax:
      content: public ReactorDispatcher(final Reactor reactor)
      parameters:
        - id: reactor
          type: 723aaf67
references:
  - uid: 723aaf67
    spec.java:
      - name: final Reactor
        fullName: final Reactor
  - uid: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.ReactorDispatcher*
    name: ReactorDispatcher
    nameWithType: ReactorDispatcher.ReactorDispatcher
    fullName: com.microsoft.azure.eventhubs.amqp.ReactorDispatcher.ReactorDispatcher
    package: com.microsoft.azure.eventhubs.amqp
  - uid: 93de0ef9com.microsoft.azure.eventhubs.amqp._dispatch_handler
    spec.java:
      - name: 'final '
        fullName: 'final '
      - uid: com.microsoft.azure.eventhubs.amqp._dispatch_handler
        name: DispatchHandler
        fullName: com.microsoft.azure.eventhubs.amqp.DispatchHandler
        href: com.microsoft.azure.eventhubs.amqp._dispatch_handler.yml
  - uid: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.invoke*
    name: invoke
    nameWithType: ReactorDispatcher.invoke
    fullName: void com.microsoft.azure.eventhubs.amqp.ReactorDispatcher.invoke
    package: com.microsoft.azure.eventhubs.amqp
  - uid: cd225469
    spec.java:
      - name: final int
        fullName: final int
  - uid: com.microsoft.azure.eventhubs.amqp._dispatch_handler
    parent: com.microsoft.azure.eventhubs.amqp
    href: com.microsoft.azure.eventhubs.amqp._dispatch_handler.yml
    name: DispatchHandler
    nameWithType: DispatchHandler
    fullName: com.microsoft.azure.eventhubs.amqp.DispatchHandler
    type: Class
    syntax:
      content: public class DispatchHandler
  - uid: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher
    parent: com.microsoft.azure.eventhubs.amqp
    href: com.microsoft.azure.eventhubs.amqp._reactor_dispatcher.yml
    name: ReactorDispatcher
    nameWithType: ReactorDispatcher
    fullName: com.microsoft.azure.eventhubs.amqp.ReactorDispatcher
    type: Class
    summary: "<p><span data-ttu-id=\"d4e71-108\">\r\n\r\n  <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref> ist nicht threadsicher - alle Aufrufe an <xref uid=\"\" data-throw-if-not-resolved=\"false\">Proton</xref> -APIs werden sollten - Reaktor-Thread.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-108\">\r\n\r\n  <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref> is not thread-safe - all calls to <xref uid=\"\" data-throw-if-not-resolved=\"false\">Proton</xref> API's should be - on the Reactor Thread.</span></span> <span data-ttu-id=\"d4e71-109\"><xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref> funktioniert der Out-of-Box für alle ereignisgesteuert-API - ex: OnReceive – die nach OnSocketRead auslösen könnten.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-109\"><xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref> works out-of-box for all event driven API - ex: onReceive - which could raise upon onSocketRead.</span></span> <span data-ttu-id=\"d4e71-110\"><xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref> hat-APIs unterstützt, z. B. Send() Out-of-Box - die potenziell in anderen Thread der Reaktor ausgeführt werden kann.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-110\"><xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref> didn't support API's like Send() out-of-box - which could potentially run on different thread to that of Reactor.</span></span> <span data-ttu-id=\"d4e71-111\">Die folgenden Hilfsprogrammklasse daher dient zum Generieren eines Ereignisses Hook <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref>des delegationsmuster Ereignis.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-111\">So, the following utility class is used to generate an Event to hook into <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref>'s event delegation pattern.</span></span> <span data-ttu-id=\"d4e71-112\">Er verwendet ein <xref uid=\"\" data-throw-if-not-resolved=\"false\">Pipe</xref> als die e/a, auf welche Reaktor überwacht.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-112\">It uses a <xref uid=\"\" data-throw-if-not-resolved=\"false\">Pipe</xref> as the IO on which Reactor Listens to.</span></span> <span data-ttu-id=\"d4e71-113\">Kardinalität: mehrere <xref uid=\"com.microsoft.azure.eventhubs.amqp._reactor_dispatcher\" data-throw-if-not-resolved=\"false\">ReactorDispatcher</xref>des angefügt werden konnte, um 1 <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref>.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-113\">Cardinality: multiple <xref uid=\"com.microsoft.azure.eventhubs.amqp._reactor_dispatcher\" data-throw-if-not-resolved=\"false\">ReactorDispatcher</xref>'s could be attached to 1 <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref>.</span></span> <span data-ttu-id=\"d4e71-114\">Jede <xref uid=\"com.microsoft.azure.eventhubs.amqp._reactor_dispatcher\" data-throw-if-not-resolved=\"false\">ReactorDispatcher</xref> sollten synchron - initialisiert werden, wie es den API-Aufrufe <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reaktor</xref> die nicht threadsicher ist.</span><span class=\"sxs-lookup\"><span data-stu-id=\"d4e71-114\">Each <xref uid=\"com.microsoft.azure.eventhubs.amqp._reactor_dispatcher\" data-throw-if-not-resolved=\"false\">ReactorDispatcher</xref> should be initialized Synchronously - as it calls API in <xref uid=\"\" data-throw-if-not-resolved=\"false\">Reactor</xref> which is not thread-safe.</span></span> </p>"
    syntax: *ref_1